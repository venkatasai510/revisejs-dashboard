{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Revise = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst axios_1 = tslib_1.__importDefault(require(\"axios\"));\n\nlet BASE_URL = \"https://api.revise.network\";\n\nfunction getHeaders(_ref) {\n  let {\n    token\n  } = _ref;\n  return {\n    headers: {\n      Authorization: `Bearer ${token}`\n    }\n  };\n}\n\nconst fetchCollectionsAPI = async _ref2 => {\n  let {\n    token\n  } = _ref2;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/collections`, getHeaders({\n    token\n  }));\n  return data;\n};\n\nconst fetchCollectionAPI = async _ref3 => {\n  let {\n    token,\n    collectionId\n  } = _ref3;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/collections/${collectionId}`, getHeaders({\n    token\n  }));\n  return data;\n};\n\nconst addCollectionAPI = async _ref4 => {\n  let {\n    token,\n    info\n  } = _ref4;\n  const {\n    data\n  } = await axios_1.default.post(`${BASE_URL}/collections`, {\n    collectionName: info.name,\n    collectionURI: info.uri\n  }, getHeaders({\n    token\n  }));\n  return data;\n};\n\nconst addNFTAPI = async _ref5 => {\n  let {\n    token,\n    collectionId,\n    info\n  } = _ref5;\n  const tokenObj = {\n    tokenId: info.tokenId,\n    name: info.name,\n    image: info.image,\n    description: info.description,\n    metaData: info.metaData\n  };\n\n  if (collectionId) {\n    const {\n      data\n    } = await axios_1.default.post(`${BASE_URL}/collections/${collectionId}/nfts`, tokenObj, getHeaders({\n      token\n    }));\n    return data;\n  }\n\n  const {\n    data\n  } = await axios_1.default.post(`${BASE_URL}/nfts/addnft`, tokenObj, getHeaders({\n    token\n  }));\n  return data;\n};\n\nconst updateNFTAPI = async _ref6 => {\n  let {\n    token,\n    nftId,\n    info\n  } = _ref6;\n  const {\n    data\n  } = await axios_1.default.put(`${BASE_URL}/nfts/${nftId}`, {\n    tokenId: info.tokenId,\n    name: info.name,\n    image: info.image,\n    description: info.description,\n    metaData: info.metaData\n  }, getHeaders({\n    token\n  }));\n  return data;\n};\n\nconst fetchCollectionNFTsAPI = async _ref7 => {\n  let {\n    token,\n    collectionId\n  } = _ref7;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/collections/${collectionId}/nfts`, getHeaders({\n    token\n  }));\n  return data.map(nft => {\n    try {\n      const nftEntity = Object.assign(Object.assign({}, nft), {\n        metaData: JSON.parse(nft.metaData)\n      });\n\n      if (nftEntity.id) {\n        return Object.assign(Object.assign({}, nftEntity), {\n          message: 'ID exists'\n        });\n      }\n\n      return nftEntity;\n    } catch (error) {\n      const nftEntity = Object.assign(Object.assign({}, nft), {\n        metaData: []\n      });\n      return nftEntity;\n    }\n  });\n};\n\nconst fetchNFTsAPI = async _ref8 => {\n  let {\n    token,\n    collectionId\n  } = _ref8;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/nfts`, getHeaders({\n    token\n  }));\n  return data.map(nft => {\n    try {\n      const nftEntity = Object.assign(Object.assign({}, nft), {\n        metaData: JSON.parse(nft.metaData)\n      });\n\n      if (nftEntity.id) {\n        return Object.assign(Object.assign({}, nftEntity), {\n          message: 'ID exists'\n        });\n      }\n\n      return nftEntity;\n    } catch (error) {\n      const nftEntity = Object.assign(Object.assign({}, nft), {\n        metaData: []\n      });\n      return nftEntity;\n    }\n  });\n};\n\nconst fetchNFTAPI = async _ref9 => {\n  let {\n    token,\n    nftId\n  } = _ref9;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/nfts/${nftId}`, getHeaders({\n    token\n  }));\n\n  try {\n    data.metaData = JSON.parse(data.metaData);\n  } catch (error) {\n    data.metaData = {};\n  }\n\n  return data;\n};\n\nconst fetchRevisionsAPI = async _ref10 => {\n  let {\n    token,\n    nftId\n  } = _ref10;\n  const {\n    data\n  } = await axios_1.default.get(`${BASE_URL}/nfts/${nftId}/revisions`, getHeaders({\n    token\n  }));\n\n  try {\n    data.metaData = JSON.parse(data.metaData);\n    data.revisions = data.revisions.map(rev => {\n      try {\n        rev.metaData = JSON.parse(rev.metaData);\n      } catch (error) {\n        rev.metaData = [];\n      }\n\n      return rev;\n    });\n    return data;\n  } catch (error) {\n    throw {\n      response: {\n        data: {\n          code: \"INVMD\",\n          message: \"Invalid metadata\"\n        }\n      }\n    };\n  }\n};\n\nconst deleteNFTAPI = async _ref11 => {\n  let {\n    token,\n    tokenId\n  } = _ref11;\n  const {\n    data\n  } = await axios_1.default.delete(`${BASE_URL}/nfts/${tokenId}`, getHeaders({\n    token\n  }));\n  return data;\n};\n\nclass NFTObj {\n  constructor(_ref12) {\n    let {\n      auth,\n      nft\n    } = _ref12;\n    this.auth = auth;\n    this.nft = nft;\n  }\n\n  metaDataAsMap() {\n    return this.nft.metaData.reduce((newObj, cur) => {\n      if (!newObj) newObj = {};\n      newObj[Object.keys(cur)[0]] = cur[Object.keys(cur)[0]];\n      return newObj;\n    });\n  }\n\n  setMetaData(obj) {\n    const d = Object.keys(obj).map(key => {\n      const newObj = {};\n      newObj[key] = obj[key];\n      return newObj;\n    });\n    this.nft.metaData = d;\n  }\n\n  setProperty(key, value) {\n    const metaData = this.metaDataAsMap(); // let isNewProperty = true;\n    // this.nft.metaData = this.nft.metaData.map((attr: Attribute) => {\n    //   const temp = {...attr};\n    //   if (Object.keys(temp)[0] === key) {\n    //     isNewProperty = false;\n    //     temp[key] = value;\n    //   }\n    //   return temp;\n    // })\n    // if (isNewProperty) {\n    //   const o = {};\n    //   o[key] = value;\n    //   this.nft.metaData.push(o);\n    // }\n\n    metaData[key] = value;\n    this.setMetaData(metaData);\n    return this;\n  }\n\n  deleteProperty(key) {\n    this.nft.metaData = this.nft.metaData.filter(attr => Object.keys(attr)[0] !== key);\n    return this;\n  }\n\n  setName(name) {\n    this.nft.name = name;\n    return this;\n  }\n\n  setImage(image) {\n    this.nft.image = image;\n    return this;\n  }\n\n  setTokenId(tokenId) {\n    this.nft.tokenId = tokenId;\n    return this;\n  }\n\n  setDescription(description) {\n    this.nft.description = description;\n    return this;\n  }\n\n  save() {\n    return updateNFTAPI({\n      token: this.auth,\n      nftId: this.nft.id,\n      info: {\n        tokenId: this.nft.tokenId,\n        name: this.nft.name,\n        image: this.nft.image,\n        description: this.nft.description,\n        metaData: this.nft.metaData\n      }\n    });\n  } // export() {\n  //   return \"ipfs://...\";\n  // }\n\n\n  async revisions() {\n    return (await fetchRevisionsAPI({\n      token: this.auth,\n      nftId: this.nft.id\n    })).revisions;\n  }\n\n  async revisionsLink() {\n    return `https://revise.link/revision/${this.nft.id}`;\n  }\n\n}\n\nclass Revise {\n  constructor(_ref13) {\n    let {\n      auth,\n      serverURL\n    } = _ref13;\n    this.auth = auth;\n\n    if (serverURL !== undefined) {\n      BASE_URL = serverURL;\n    }\n  }\n\n  fetchCollections() {\n    return fetchCollectionsAPI({\n      token: this.auth\n    });\n  }\n\n  fetchCollection(collectionId) {\n    return fetchCollectionAPI({\n      token: this.auth,\n      collectionId\n    });\n  }\n\n  addCollection(_ref14) {\n    let {\n      name,\n      uri\n    } = _ref14;\n    return addCollectionAPI({\n      token: this.auth,\n      info: {\n        name,\n        uri\n      }\n    });\n  }\n\n  addNFT(tokenData, properties, collectionId) {\n    const {\n      tokenId,\n      name,\n      image,\n      description\n    } = tokenData;\n    const info = {\n      tokenId,\n      name,\n      image,\n      description: description || \"\",\n      metaData: properties\n    };\n\n    if (collectionId) {\n      return addNFTAPI({\n        token: this.auth,\n        collectionId,\n        info\n      });\n    }\n\n    return addNFTAPI({\n      token: this.auth,\n      info\n    });\n  }\n\n  async updateNFT(nftId) {\n    return this.nft(await this.fetchNFT(nftId));\n  }\n\n  nft(nft) {\n    return new NFTObj({\n      auth: this.auth,\n      nft\n    });\n  }\n\n  fetchNFTs(collectionId) {\n    if (collectionId === undefined || collectionId === null) {\n      return fetchNFTsAPI({\n        token: this.auth,\n        collectionId\n      });\n    }\n\n    return fetchCollectionNFTsAPI({\n      token: this.auth,\n      collectionId\n    });\n  }\n\n  fetchNFT(nftId) {\n    return fetchNFTAPI({\n      token: this.auth,\n      nftId\n    });\n  }\n\n  deleteNFT(nftId) {\n    return deleteNFTAPI({\n      token: this.auth,\n      tokenId: nftId\n    });\n  }\n\n  fetchRevisions(nftId) {\n    return fetchRevisionsAPI({\n      token: this.auth,\n      nftId\n    });\n  }\n\n  every(durationString) {\n    return new Automation(new Duration(durationString));\n  }\n\n}\n\nexports.Revise = Revise;\n\nclass Automation {\n  constructor(duration) {\n    this.duration = duration;\n  }\n\n  listenTo(api) {\n    if (typeof api !== 'string' && typeof api !== 'function') {\n      throw new Error('invalid API source shared');\n    }\n\n    if (typeof api === 'string') {\n      this.apiResolver = async () => (await axios_1.default.get(api)).data;\n    }\n\n    if (typeof api === 'function') {\n      this.apiResolver = api;\n    }\n\n    return this;\n  }\n\n  async start(cb) {\n    const data = await this.apiResolver();\n    cb(data);\n    setTimeout(() => {\n      this.start(cb);\n    }, this.duration.getMiliseconds());\n  }\n\n}\n\nclass Duration {\n  constructor(durationString) {\n    this.durationString = durationString;\n  }\n\n  getMiliseconds() {\n    try {\n      if (this.durationString.toLowerCase().includes('s')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data) * 1000;\n      }\n\n      if (this.durationString.toLowerCase().includes('m')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data) * 60000;\n      }\n\n      if (this.durationString.toLowerCase().includes('h')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data) * 3600000;\n      }\n    } catch (error) {\n      throw new Error(\"Invalid time format passed\");\n    }\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AAGA,IAAIA,QAAQ,GAAG,4BAAf;;AACA,SAASC,UAAT,OAA6B;EAAA,IAAT;IAAEC;EAAF,CAAS;EAC3B,OAAO;IACLC,OAAO,EAAE;MACPC,aAAa,EAAE,UAAUF,KAAK;IADvB;EADJ,CAAP;AAKD;;AAED,MAAMG,mBAAmB,GAAG,eAAoB;EAAA,IAAb;IAAEH;EAAF,CAAa;EAC9C,MAAM;IAAEI;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,cADU,EAErBC,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;EAIA,OAAOI,IAAP;AACD,CAND;;AAOA,MAAMG,kBAAkB,GAAG,eAAkC;EAAA,IAA3B;IAAEP,KAAF;IAASQ;EAAT,CAA2B;EAC3D,MAAM;IAAEJ;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,gBAAgBU,YAAY,EADlB,EAErBT,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;EAIA,OAAOI,IAAP;AACD,CAND;;AAOA,MAAMK,gBAAgB,GAAG,eAA0B;EAAA,IAAnB;IAAET,KAAF;IAASU;EAAT,CAAmB;EACjD,MAAM;IAAEN;EAAF,IAAW,MAAMC,gBAAMM,IAAN,CACrB,GAAGb,QAAQ,cADU,EAErB;IACEc,cAAc,EAAEF,IAAI,CAACG,IADvB;IAEEC,aAAa,EAAEJ,IAAI,CAACK;EAFtB,CAFqB,EAMrBhB,UAAU,CAAC;IAAEC;EAAF,CAAD,CANW,CAAvB;EAQA,OAAOI,IAAP;AACD,CAVD;;AAWA,MAAMY,SAAS,GAAG,eAAwF;EAAA,IAAjF;IAAEhB,KAAF;IAASQ,YAAT;IAAuBE;EAAvB,CAAiF;EACxG,MAAMO,QAAQ,GAAG;IACfC,OAAO,EAAER,IAAI,CAACQ,OADC;IAEfL,IAAI,EAAEH,IAAI,CAACG,IAFI;IAGfM,KAAK,EAAET,IAAI,CAACS,KAHG;IAIfC,WAAW,EAAEV,IAAI,CAACU,WAJH;IAKfC,QAAQ,EAAEX,IAAI,CAACW;EALA,CAAjB;;EAOA,IAAIb,YAAJ,EAAkB;IAChB,MAAM;MAAEJ;IAAF,IAAW,MAAMC,gBAAMM,IAAN,CAAW,GAAGb,QAAQ,gBAAgBU,YAAY,OAAlD,EAA2DS,QAA3D,EAAqElB,UAAU,CAAC;MAAEC;IAAF,CAAD,CAA/E,CAAvB;IACA,OAAOI,IAAP;EACD;;EACD,MAAM;IAAEA;EAAF,IAAW,MAAMC,gBAAMM,IAAN,CAAW,GAAGb,QAAQ,cAAtB,EAAsCmB,QAAtC,EAAgDlB,UAAU,CAAC;IAAEC;EAAF,CAAD,CAA1D,CAAvB;EACA,OAAOI,IAAP;AACD,CAdD;;AAeA,MAAMkB,YAAY,GAAG,eAAiC;EAAA,IAA1B;IAAEtB,KAAF;IAASuB,KAAT;IAAgBb;EAAhB,CAA0B;EACpD,MAAM;IAAEN;EAAF,IAAW,MAAMC,gBAAMmB,GAAN,CACrB,GAAG1B,QAAQ,SAASyB,KAAK,EADJ,EAErB;IACEL,OAAO,EAAER,IAAI,CAACQ,OADhB;IAEEL,IAAI,EAAEH,IAAI,CAACG,IAFb;IAGEM,KAAK,EAAET,IAAI,CAACS,KAHd;IAIEC,WAAW,EAAEV,IAAI,CAACU,WAJpB;IAKEC,QAAQ,EAAEX,IAAI,CAACW;EALjB,CAFqB,EASrBtB,UAAU,CAAC;IAAEC;EAAF,CAAD,CATW,CAAvB;EAWA,OAAOI,IAAP;AACD,CAbD;;AAcA,MAAMqB,sBAAsB,GAAG,eAAkC;EAAA,IAA3B;IAAEzB,KAAF;IAASQ;EAAT,CAA2B;EAC/D,MAAM;IAAEJ;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,gBAAgBU,YAAY,OADlB,EAErBT,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;EAIA,OAAOI,IAAI,CAACsB,GAAL,CAAUC,GAAD,IAAa;IAC3B,IAAI;MACF,MAAMC,SAAS,mCAAkBD,GAAlB,GAAqB;QAAEN,QAAQ,EAAEQ,IAAI,CAACC,KAAL,CAAWH,GAAG,CAACN,QAAf;MAAZ,CAArB,CAAf;;MACA,IAAIO,SAAS,CAACG,EAAd,EAAkB;QAChB,uCAAWH,SAAX,GAAoB;UAAEI,OAAO,EAAE;QAAX,CAApB;MACD;;MACD,OAAOJ,SAAP;IACD,CAND,CAME,OAAOK,KAAP,EAAc;MACd,MAAML,SAAS,mCAAkBD,GAAlB,GAAqB;QAAEN,QAAQ,EAAE;MAAZ,CAArB,CAAf;MACA,OAAOO,SAAP;IACD;EACF,CAXM,CAAP;AAYD,CAjBD;;AAkBA,MAAMM,YAAY,GAAG,eAAkC;EAAA,IAA3B;IAAElC,KAAF;IAASQ;EAAT,CAA2B;EACrD,MAAM;IAAEJ;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,OADU,EAErBC,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;EAIA,OAAOI,IAAI,CAACsB,GAAL,CAAUC,GAAD,IAAa;IAC3B,IAAI;MACF,MAAMC,SAAS,mCAAkBD,GAAlB,GAAqB;QAAEN,QAAQ,EAAEQ,IAAI,CAACC,KAAL,CAAWH,GAAG,CAACN,QAAf;MAAZ,CAArB,CAAf;;MACA,IAAIO,SAAS,CAACG,EAAd,EAAkB;QAChB,uCAAWH,SAAX,GAAoB;UAAEI,OAAO,EAAE;QAAX,CAApB;MACD;;MACD,OAAOJ,SAAP;IACD,CAND,CAME,OAAOK,KAAP,EAAc;MACd,MAAML,SAAS,mCAAkBD,GAAlB,GAAqB;QAAEN,QAAQ,EAAE;MAAZ,CAArB,CAAf;MACA,OAAOO,SAAP;IACD;EACF,CAXM,CAAP;AAYD,CAjBD;;AAkBA,MAAMO,WAAW,GAAG,eAA2B;EAAA,IAApB;IAAEnC,KAAF;IAASuB;EAAT,CAAoB;EAC7C,MAAM;IAAEnB;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,SAASyB,KAAK,EADJ,EAErBxB,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;;EAIA,IAAI;IACFI,IAAI,CAACiB,QAAL,GAAgBQ,IAAI,CAACC,KAAL,CAAW1B,IAAI,CAACiB,QAAhB,CAAhB;EACD,CAFD,CAEE,OAAOY,KAAP,EAAc;IACd7B,IAAI,CAACiB,QAAL,GAAgB,EAAhB;EACD;;EACD,OAAOjB,IAAP;AACD,CAXD;;AAYA,MAAMgC,iBAAiB,GAAG,gBAA2B;EAAA,IAApB;IAAEpC,KAAF;IAASuB;EAAT,CAAoB;EACnD,MAAM;IAAEnB;EAAF,IAAW,MAAMC,gBAAMC,GAAN,CACrB,GAAGR,QAAQ,SAASyB,KAAK,YADJ,EAErBxB,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;;EAIA,IAAI;IACFI,IAAI,CAACiB,QAAL,GAAgBQ,IAAI,CAACC,KAAL,CAAW1B,IAAI,CAACiB,QAAhB,CAAhB;IACAjB,IAAI,CAACiC,SAAL,GAAiBjC,IAAI,CAACiC,SAAL,CAAeX,GAAf,CAAmBY,GAAG,IAAG;MACxC,IAAI;QACFA,GAAG,CAACjB,QAAJ,GAAeQ,IAAI,CAACC,KAAL,CAAWQ,GAAG,CAACjB,QAAf,CAAf;MACD,CAFD,CAEE,OAAOY,KAAP,EAAc;QACdK,GAAG,CAACjB,QAAJ,GAAe,EAAf;MACD;;MACD,OAAOiB,GAAP;IACD,CAPgB,CAAjB;IAQA,OAAOlC,IAAP;EACD,CAXD,CAWE,OAAO6B,KAAP,EAAc;IACd,MAAM;MACJM,QAAQ,EAAE;QAAEnC,IAAI,EAAE;UAAEoC,IAAI,EAAE,OAAR;UAAiBR,OAAO,EAAE;QAA1B;MAAR;IADN,CAAN;EAGD;AACF,CArBD;;AAsBA,MAAMS,YAAY,GAAG,gBAA6B;EAAA,IAAtB;IAAEzC,KAAF;IAASkB;EAAT,CAAsB;EAChD,MAAM;IAAEd;EAAF,IAAW,MAAMC,gBAAMqC,MAAN,CACrB,GAAG5C,QAAQ,SAASoB,OAAO,EADN,EAErBnB,UAAU,CAAC;IAAEC;EAAF,CAAD,CAFW,CAAvB;EAIA,OAAOI,IAAP;AACD,CAND;;AA4BA,MAAMuC,MAAN,CAAY;EAIVC,oBAAuD;IAAA,IAA3C;MAACC,IAAD;MAAOlB;IAAP,CAA2C;IACrD,KAAKkB,IAAL,GAAYA,IAAZ;IACA,KAAKlB,GAAL,GAAWA,GAAX;EACD;;EACOmB,aAAa;IACnB,OAAO,KAAKnB,GAAL,CAASN,QAAT,CAAkB0B,MAAlB,CAAyB,CAACC,MAAD,EAAyCC,GAAzC,KAAgD;MAC9E,IAAI,CAAED,MAAN,EAAcA,MAAM,GAAG,EAAT;MACdA,MAAM,CAACE,MAAM,CAACC,IAAP,CAAYF,GAAZ,EAAiB,CAAjB,CAAD,CAAN,GAA8BA,GAAG,CAACC,MAAM,CAACC,IAAP,CAAYF,GAAZ,EAAiB,CAAjB,CAAD,CAAjC;MACA,OAAOD,MAAP;IACD,CAJM,CAAP;EAKD;;EACOI,WAAW,CAACC,GAAD,EAAqC;IACtD,MAAMC,CAAC,GAAGJ,MAAM,CAACC,IAAP,CAAYE,GAAZ,EAAiB3B,GAAjB,CAAsB6B,GAAD,IAAQ;MACrC,MAAMP,MAAM,GAAG,EAAf;MACAA,MAAM,CAACO,GAAD,CAAN,GAAcF,GAAG,CAACE,GAAD,CAAjB;MACA,OAAOP,MAAP;IACD,CAJS,CAAV;IAKA,KAAKrB,GAAL,CAASN,QAAT,GAAoBiC,CAApB;EACD;;EACDE,WAAW,CAACD,GAAD,EAAcE,KAAd,EAAkC;IAC3C,MAAMpC,QAAQ,GAAG,KAAKyB,aAAL,EAAjB,CAD2C,CAE3C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACAzB,QAAQ,CAACkC,GAAD,CAAR,GAAgBE,KAAhB;IACA,KAAKL,WAAL,CAAiB/B,QAAjB;IACA,OAAO,IAAP;EACD;;EACDqC,cAAc,CAACH,GAAD,EAAY;IACxB,KAAK5B,GAAL,CAASN,QAAT,GAAoB,KAAKM,GAAL,CAASN,QAAT,CAAkBsC,MAAlB,CAA0BC,IAAD,IAAqBV,MAAM,CAACC,IAAP,CAAYS,IAAZ,EAAkB,CAAlB,MAAyBL,GAAvE,CAApB;IACA,OAAO,IAAP;EACD;;EACDM,OAAO,CAAChD,IAAD,EAAY;IACjB,KAAKc,GAAL,CAASd,IAAT,GAAgBA,IAAhB;IACA,OAAO,IAAP;EACD;;EACDiD,QAAQ,CAAC3C,KAAD,EAAa;IACnB,KAAKQ,GAAL,CAASR,KAAT,GAAiBA,KAAjB;IACA,OAAO,IAAP;EACD;;EACD4C,UAAU,CAAC7C,OAAD,EAAe;IACvB,KAAKS,GAAL,CAAST,OAAT,GAAmBA,OAAnB;IACA,OAAO,IAAP;EACD;;EACD8C,cAAc,CAAC5C,WAAD,EAAoB;IAChC,KAAKO,GAAL,CAASP,WAAT,GAAuBA,WAAvB;IACA,OAAO,IAAP;EACD;;EACD6C,IAAI;IACF,OAAO3C,YAAY,CAAC;MAClBtB,KAAK,EAAE,KAAK6C,IADM;MAElBtB,KAAK,EAAE,KAAKI,GAAL,CAASI,EAFE;MAGlBrB,IAAI,EAAE;QACJQ,OAAO,EAAE,KAAKS,GAAL,CAAST,OADd;QAEJL,IAAI,EAAE,KAAKc,GAAL,CAASd,IAFX;QAGJM,KAAK,EAAE,KAAKQ,GAAL,CAASR,KAHZ;QAIJC,WAAW,EAAE,KAAKO,GAAL,CAASP,WAJlB;QAKJC,QAAQ,EAAE,KAAKM,GAAL,CAASN;MALf;IAHY,CAAD,CAAnB;EAWD,CA3ES,CA4EV;EACA;EACA;;;EACe,MAATgB,SAAS;IACb,OAAO,CAAC,MAAMD,iBAAiB,CAAC;MAACpC,KAAK,EAAE,KAAK6C,IAAb;MAAmBtB,KAAK,EAAE,KAAKI,GAAL,CAASI;IAAnC,CAAD,CAAxB,EAAkEM,SAAzE;EACD;;EACkB,MAAb6B,aAAa;IACjB,OAAO,gCAAgC,KAAKvC,GAAL,CAASI,EAAE,EAAlD;EACD;;AApFS;;AAwFZ,MAAaoC,MAAb,CAAmB;EAEjBvB,oBAA2C;IAAA,IAA/B;MAACC,IAAD;MAAOuB;IAAP,CAA+B;IACzC,KAAKvB,IAAL,GAAYA,IAAZ;;IACA,IAAIuB,SAAS,KAAKC,SAAlB,EAA6B;MAC3BvE,QAAQ,GAAGsE,SAAX;IACD;EACF;;EAEDE,gBAAgB;IACd,OAAOnE,mBAAmB,CAAC;MAACH,KAAK,EAAE,KAAK6C;IAAb,CAAD,CAA1B;EACD;;EACD0B,eAAe,CAAC/D,YAAD,EAAa;IAC1B,OAAOD,kBAAkB,CAAC;MAACP,KAAK,EAAE,KAAK6C,IAAb;MAAmBrC;IAAnB,CAAD,CAAzB;EACD;;EACDgE,aAAa,SAAY;IAAA,IAAX;MAAC3D,IAAD;MAAOE;IAAP,CAAW;IACvB,OAAON,gBAAgB,CAAC;MAACT,KAAK,EAAE,KAAK6C,IAAb;MAAmBnC,IAAI,EAAE;QAACG,IAAD;QAAOE;MAAP;IAAzB,CAAD,CAAvB;EACD;;EACD0D,MAAM,CAACC,SAAD,EAA8BC,UAA9B,EAAuDnE,YAAvD,EAA4E;IAChF,MAAM;MAACU,OAAD;MAAUL,IAAV;MAAgBM,KAAhB;MAAuBC;IAAvB,IAAsCsD,SAA5C;IACA,MAAMhE,IAAI,GAAG;MACXQ,OADW;MAEXL,IAFW;MAGXM,KAHW;MAIXC,WAAW,EAAEA,WAAW,IAAI,EAJjB;MAKXC,QAAQ,EAAEsD;IALC,CAAb;;IAOA,IAAInE,YAAJ,EAAkB;MAChB,OAAOQ,SAAS,CAAC;QAAChB,KAAK,EAAE,KAAK6C,IAAb;QAAmBrC,YAAnB;QAAiCE;MAAjC,CAAD,CAAhB;IACD;;IACD,OAAOM,SAAS,CAAC;MAAChB,KAAK,EAAE,KAAK6C,IAAb;MAAmBnC;IAAnB,CAAD,CAAhB;EACD;;EACc,MAATkE,SAAS,CAACrD,KAAD,EAAc;IAC3B,OAAO,KAAKI,GAAL,CAAS,MAAM,KAAKkD,QAAL,CAActD,KAAd,CAAf,CAAP;EACD;;EACDI,GAAG,CAACA,GAAD,EAAe;IAChB,OAAO,IAAIgB,MAAJ,CAAW;MAACE,IAAI,EAAE,KAAKA,IAAZ;MAAkBlB;IAAlB,CAAX,CAAP;EACD;;EACDmD,SAAS,CAACtE,YAAD,EAAsB;IAC7B,IAAIA,YAAY,KAAK6D,SAAjB,IAA8B7D,YAAY,KAAK,IAAnD,EAAyD;MACvD,OAAO0B,YAAY,CAAC;QAAClC,KAAK,EAAE,KAAK6C,IAAb;QAAmBrC;MAAnB,CAAD,CAAnB;IACD;;IACD,OAAOiB,sBAAsB,CAAC;MAACzB,KAAK,EAAE,KAAK6C,IAAb;MAAmBrC;IAAnB,CAAD,CAA7B;EACD;;EACDqE,QAAQ,CAACtD,KAAD,EAAc;IACpB,OAAOY,WAAW,CAAC;MAACnC,KAAK,EAAE,KAAK6C,IAAb;MAAmBtB;IAAnB,CAAD,CAAlB;EACD;;EACDwD,SAAS,CAACxD,KAAD,EAAc;IACrB,OAAOkB,YAAY,CAAC;MAACzC,KAAK,EAAE,KAAK6C,IAAb;MAAmB3B,OAAO,EAAEK;IAA5B,CAAD,CAAnB;EACD;;EACDyD,cAAc,CAACzD,KAAD,EAAc;IAC1B,OAAOa,iBAAiB,CAAC;MAACpC,KAAK,EAAE,KAAK6C,IAAb;MAAmBtB;IAAnB,CAAD,CAAxB;EACD;;EAED0D,KAAK,CAACC,cAAD,EAAuB;IAC1B,OAAO,IAAIC,UAAJ,CAAe,IAAIC,QAAJ,CAAaF,cAAb,CAAf,CAAP;EACD;;AAxDgB;;AAAnBG;;AA8DA,MAAMF,UAAN,CAAgB;EAIdvC,YAAY0C,QAAZ,EAA8B;IAC5B,KAAKA,QAAL,GAAgBA,QAAhB;EACD;;EACMC,QAAQ,CAACC,GAAD,EAAuB;IACpC,IAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9C,EAA0D;MACxD,MAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;IACD;;IACD,IAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;MAC3B,KAAKE,WAAL,GAAmB,YAAY,CAAC,MAAMrF,gBAAMC,GAAN,CAAUkF,GAAV,CAAP,EAAuBpF,IAAtD;IACD;;IACD,IAAI,OAAOoF,GAAP,KAAe,UAAnB,EAA+B;MAC7B,KAAKE,WAAL,GAAmBF,GAAnB;IACD;;IACD,OAAO,IAAP;EACD;;EACiB,MAALG,KAAK,CAACC,EAAD,EAAa;IAC7B,MAAMxF,IAAI,GAAG,MAAM,KAAKsF,WAAL,EAAnB;IACAE,EAAE,CAACxF,IAAD,CAAF;IACAyF,UAAU,CAAC,MAAK;MACd,KAAKF,KAAL,CAAWC,EAAX;IACD,CAFS,EAEP,KAAKN,QAAL,CAAcQ,cAAd,EAFO,CAAV;EAGD;;AAzBa;;AA4BhB,MAAMV,QAAN,CAAc;EAIZxC,YAAYsC,cAAZ,EAAkC;IAChC,KAAKA,cAAL,GAAsBA,cAAtB;EACD;;EACMY,cAAc;IACnB,IAAI;MACF,IAAI,KAAKZ,cAAL,CAAoBa,WAApB,GAAkCC,QAAlC,CAA2C,GAA3C,CAAJ,EAAqD;QACnD,MAAM5F,IAAI,GAAG,KAAK8E,cAAL,CAAoBa,WAApB,GAAkCE,KAAlC,CAAwC,GAAxC,EAA6C,CAA7C,CAAb;QACA,OAAOC,QAAQ,CAAC9F,IAAD,CAAR,GAAe,IAAtB;MACD;;MACD,IAAI,KAAK8E,cAAL,CAAoBa,WAApB,GAAkCC,QAAlC,CAA2C,GAA3C,CAAJ,EAAqD;QACnD,MAAM5F,IAAI,GAAG,KAAK8E,cAAL,CAAoBa,WAApB,GAAkCE,KAAlC,CAAwC,GAAxC,EAA6C,CAA7C,CAAb;QACA,OAAOC,QAAQ,CAAC9F,IAAD,CAAR,GAAe,KAAtB;MACD;;MACD,IAAI,KAAK8E,cAAL,CAAoBa,WAApB,GAAkCC,QAAlC,CAA2C,GAA3C,CAAJ,EAAqD;QACnD,MAAM5F,IAAI,GAAG,KAAK8E,cAAL,CAAoBa,WAApB,GAAkCE,KAAlC,CAAwC,GAAxC,EAA6C,CAA7C,CAAb;QACA,OAAOC,QAAQ,CAAC9F,IAAD,CAAR,GAAe,OAAtB;MACD;IAEF,CAdD,CAcE,OAAO6B,KAAP,EAAc;MACd,MAAM,IAAIwD,KAAJ,CAAU,4BAAV,CAAN;IAED;EACF;;AA1BW","names":["BASE_URL","getHeaders","token","headers","Authorization","fetchCollectionsAPI","data","axios_1","get","fetchCollectionAPI","collectionId","addCollectionAPI","info","post","collectionName","name","collectionURI","uri","addNFTAPI","tokenObj","tokenId","image","description","metaData","updateNFTAPI","nftId","put","fetchCollectionNFTsAPI","map","nft","nftEntity","JSON","parse","id","message","error","fetchNFTsAPI","fetchNFTAPI","fetchRevisionsAPI","revisions","rev","response","code","deleteNFTAPI","delete","NFTObj","constructor","auth","metaDataAsMap","reduce","newObj","cur","Object","keys","setMetaData","obj","d","key","setProperty","value","deleteProperty","filter","attr","setName","setImage","setTokenId","setDescription","save","revisionsLink","Revise","serverURL","undefined","fetchCollections","fetchCollection","addCollection","addNFT","tokenData","properties","updateNFT","fetchNFT","fetchNFTs","deleteNFT","fetchRevisions","every","durationString","Automation","Duration","exports","duration","listenTo","api","Error","apiResolver","start","cb","setTimeout","getMiliseconds","toLowerCase","includes","split","parseInt"],"sources":["/Users/bala/Documents/revise/revisejs-dashboard/node_modules/revise-sdk/src/index.ts"],"sourcesContent":["import axios from 'axios';\nimport { Collection, NFT, NFTRevision, ReviseConfig } from './types';\n\nlet BASE_URL = \"https://api.revise.network\";\nfunction getHeaders({ token }) {\n  return {\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n  };\n}\n\nconst fetchCollectionsAPI = async ({ token }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/collections`,\n    getHeaders({ token })\n  );\n  return data as Collection[];\n};\nconst fetchCollectionAPI = async ({ token, collectionId }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/collections/${collectionId}`,\n    getHeaders({ token })\n  );\n  return data as Collection;\n};\nconst addCollectionAPI = async ({ token, info }) => {\n  const { data } = await axios.post(\n    `${BASE_URL}/collections`,\n    {\n      collectionName: info.name,\n      collectionURI: info.uri,\n    },\n    getHeaders({ token })\n  );\n  return data as Collection;\n};\nconst addNFTAPI = async ({ token, collectionId, info }: {token: any, collectionId?: string, info: any}) => {\n  const tokenObj = {\n    tokenId: info.tokenId,\n    name: info.name,\n    image: info.image,\n    description: info.description,\n    metaData: info.metaData,\n  };\n  if (collectionId) {\n    const { data } = await axios.post(`${BASE_URL}/collections/${collectionId}/nfts`, tokenObj, getHeaders({ token }));\n    return data as NFT;\n  }\n  const { data } = await axios.post(`${BASE_URL}/nfts/addnft`, tokenObj, getHeaders({ token }));\n  return data as NFT;\n};\nconst updateNFTAPI = async ({ token, nftId, info }) => {\n  const { data } = await axios.put(\n    `${BASE_URL}/nfts/${nftId}`,\n    {\n      tokenId: info.tokenId,\n      name: info.name,\n      image: info.image,\n      description: info.description,\n      metaData: info.metaData,\n    },\n    getHeaders({ token })\n  );\n  return data;\n};\nconst fetchCollectionNFTsAPI = async ({ token, collectionId }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/collections/${collectionId}/nfts`,\n    getHeaders({ token })\n  );\n  return data.map((nft: NFT) => {\n    try {\n      const nftEntity: NFTEntity = {...nft, metaData: JSON.parse(nft.metaData)};\n      if (nftEntity.id) {\n        return {...nftEntity, message: 'ID exists'}\n      }\n      return nftEntity;\n    } catch (error) {\n      const nftEntity: NFTEntity = {...nft, metaData: []};\n      return nftEntity;\n    }\n  }) as NFTEntity[];\n};\nconst fetchNFTsAPI = async ({ token, collectionId }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/nfts`,\n    getHeaders({ token })\n  );\n  return data.map((nft: NFT) => {\n    try {\n      const nftEntity: NFTEntity = {...nft, metaData: JSON.parse(nft.metaData)};\n      if (nftEntity.id) {\n        return {...nftEntity, message: 'ID exists'}\n      }\n      return nftEntity;\n    } catch (error) {\n      const nftEntity: NFTEntity = {...nft, metaData: []};\n      return nftEntity;\n    }\n  }) as NFTEntity[];\n};\nconst fetchNFTAPI = async ({ token, nftId }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/nfts/${nftId}`,\n    getHeaders({ token })\n  );\n  try {\n    data.metaData = JSON.parse(data.metaData);\n  } catch (error) {\n    data.metaData = {};\n  }\n  return data as NFTEntity;\n};\nconst fetchRevisionsAPI = async ({ token, nftId }) => {\n  const { data } = await axios.get(\n    `${BASE_URL}/nfts/${nftId}/revisions`,\n    getHeaders({ token })\n  );\n  try {\n    data.metaData = JSON.parse(data.metaData);\n    data.revisions = data.revisions.map(rev => {\n      try {\n        rev.metaData = JSON.parse(rev.metaData);\n      } catch (error) {\n        rev.metaData = [];\n      }\n      return rev;\n    });\n    return data as RevisionList;\n  } catch (error) {\n    throw {\n      response: { data: { code: \"INVMD\", message: \"Invalid metadata\" } },\n    };\n  }\n};\nconst deleteNFTAPI = async ({ token, tokenId }) => {\n  const { data } = await axios.delete(\n    `${BASE_URL}/nfts/${tokenId}`,\n    getHeaders({ token })\n  );\n  return data;\n};\n\nexport interface TokenDataPartial {\n  name: string;\n  image: string;\n  tokenId: string;\n  description?: string;\n}\nexport type Attribute = {[keys in string]: string|number};\n\nexport interface RevisionList extends Omit<NFT, 'metaData'> {\n  metaData: Attribute[];\n  revisions: NFTRevisionEntity[];\n  collection: Collection;\n}\nexport interface NFTEntity extends Omit<NFT, 'metaData'> {\n  metaData: Attribute[];\n}\nexport interface NFTRevisionEntity extends Omit<NFTRevision, 'metaData'> {\n  metaData: Attribute[];\n}\n\nclass NFTObj {\n  private auth: string|undefined;\n  private nft: NFTEntity;\n  \n  constructor({auth, nft}: {auth: string, nft: NFTEntity}) {\n    this.auth = auth;\n    this.nft = nft;\n  }\n  private metaDataAsMap() {\n    return this.nft.metaData.reduce((newObj: {[i in string]: string|number}, cur) => {\n      if (! newObj) newObj = {};\n      newObj[Object.keys(cur)[0]] = cur[Object.keys(cur)[0]];\n      return newObj;\n    });\n  }\n  private setMetaData(obj: {[x in string] : number|string}) {\n    const d = Object.keys(obj).map((key) => {\n      const newObj = {};\n      newObj[key] = obj[key];\n      return newObj;\n    })\n    this.nft.metaData = d;\n  }\n  setProperty(key: string, value: string|number) {\n    const metaData = this.metaDataAsMap();\n    // let isNewProperty = true;\n    // this.nft.metaData = this.nft.metaData.map((attr: Attribute) => {\n    //   const temp = {...attr};\n    //   if (Object.keys(temp)[0] === key) {\n    //     isNewProperty = false;\n    //     temp[key] = value;\n    //   }\n    //   return temp;\n    // })\n    // if (isNewProperty) {\n    //   const o = {};\n    //   o[key] = value;\n    //   this.nft.metaData.push(o);\n    // }\n    metaData[key] = value;\n    this.setMetaData(metaData);\n    return this;\n  }\n  deleteProperty(key: string) {\n    this.nft.metaData = this.nft.metaData.filter((attr: Attribute) => Object.keys(attr)[0] !== key);\n    return this;\n  }\n  setName(name:string) {\n    this.nft.name = name;\n    return this;\n  }\n  setImage(image:string) {\n    this.nft.image = image;\n    return this;\n  }\n  setTokenId(tokenId:string) {\n    this.nft.tokenId = tokenId\n    return this;\n  }\n  setDescription(description: string) {\n    this.nft.description = description;\n    return this;\n  }\n  save() {\n    return updateNFTAPI({\n      token: this.auth,\n      nftId: this.nft.id,\n      info: {\n        tokenId: this.nft.tokenId,\n        name: this.nft.name,\n        image: this.nft.image,\n        description: this.nft.description,\n        metaData: this.nft.metaData\n      }\n    })\n  }\n  // export() {\n  //   return \"ipfs://...\";\n  // }\n  async revisions() {\n    return (await fetchRevisionsAPI({token: this.auth, nftId: this.nft.id})).revisions;\n  }\n  async revisionsLink() {\n    return `https://revise.link/revision/${this.nft.id}`;\n  }\n}\n\n\nexport class Revise {\n  private auth: string|undefined;\n  constructor({auth, serverURL}: ReviseConfig) {\n    this.auth = auth;\n    if (serverURL !== undefined) {\n      BASE_URL = serverURL;\n    }\n  }\n\n  fetchCollections() {\n    return fetchCollectionsAPI({token: this.auth})\n  }\n  fetchCollection(collectionId) {\n    return fetchCollectionAPI({token: this.auth, collectionId})\n  }\n  addCollection({name, uri}) {\n    return addCollectionAPI({token: this.auth, info: {name, uri}})\n  }\n  addNFT(tokenData: TokenDataPartial, properties: Attribute[], collectionId?: string) {\n    const {tokenId, name, image, description} = tokenData\n    const info = {\n      tokenId,\n      name,\n      image,\n      description: description || \"\",\n      metaData: properties\n    };\n    if (collectionId) {\n      return addNFTAPI({token: this.auth, collectionId, info})\n    }\n    return addNFTAPI({token: this.auth, info})\n  }\n  async updateNFT(nftId: string) {\n    return this.nft(await this.fetchNFT(nftId));\n  }\n  nft(nft: NFTEntity) {\n    return new NFTObj({auth: this.auth, nft});\n  }\n  fetchNFTs(collectionId?: string) {\n    if (collectionId === undefined || collectionId === null) {\n      return fetchNFTsAPI({token: this.auth, collectionId});\n    }\n    return fetchCollectionNFTsAPI({token: this.auth, collectionId});\n  }\n  fetchNFT(nftId: string) {\n    return fetchNFTAPI({token: this.auth, nftId});\n  }\n  deleteNFT(nftId: string) {\n    return deleteNFTAPI({token: this.auth, tokenId: nftId});\n  }\n  fetchRevisions(nftId: string) {\n    return fetchRevisionsAPI({token: this.auth, nftId});\n  }\n\n  every(durationString: string) {\n    return new Automation(new Duration(durationString));\n  }\n  // exportCollection(collectionId: string) {\n  //   return \"ipfs://...\";\n  // }\n}\n\nclass Automation {\n  private apiResolver: Function;\n  private duration: Duration;\n\n  constructor(duration: Duration) {\n    this.duration = duration;\n  }\n  public listenTo(api: string | Function) {\n    if (typeof api !== 'string' && typeof api !== 'function') {\n      throw new Error('invalid API source shared');\n    }\n    if (typeof api === 'string') {\n      this.apiResolver = async () => (await axios.get(api)).data;\n    }\n    if (typeof api === 'function') {\n      this.apiResolver = api;\n    }\n    return this;\n  }\n  public async start(cb: Function) {\n    const data = await this.apiResolver();\n    cb(data);\n    setTimeout(() => {\n      this.start(cb);\n    }, this.duration.getMiliseconds());\n  }\n}\n\nclass Duration {\n  private durationString: string;\n  private miliseconds: number;\n  \n  constructor(durationString: string) {\n    this.durationString = durationString;\n  }\n  public getMiliseconds() {\n    try {\n      if (this.durationString.toLowerCase().includes('s')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data)*1000;\n      }\n      if (this.durationString.toLowerCase().includes('m')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data)*60000;\n      }\n      if (this.durationString.toLowerCase().includes('h')) {\n        const data = this.durationString.toLowerCase().split('m')[0];\n        return parseInt(data)*3600000;\n      }\n      \n    } catch (error) {\n      throw new Error(\"Invalid time format passed\");\n      \n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}